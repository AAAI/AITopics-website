<?php

/**
 * @file
 * Provide functionality for merging taxonomy terms one into another.
 */

/**
 * Constant to use in term merge action.
 *
 * Constant denotes "do not create HTTP redirect" logic for term merge action.
 *
 * @var int
 */
define('TERM_MERGE_NO_REDIRECT', -1);

/**
 * Constant to use in term merge action.
 *
 * Constant denotes "Create a new term and use it as the term trunk" logic
 * for term merge action.
 *
 * @var int
 */
define('TERM_MERGE_NEW_TERM_TRUNK', -1);

/**
 * Implements hook_menu().
 */
function term_merge_menu() {
  $items = array();

  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/merge'] = array(
    'title' => 'Merge terms',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('term_merge_form', 3),
    'access arguments' => array('merge terms'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/merge/default'] = array(
    'title' => 'Default',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/merge/duplicates'] = array(
    'title' => 'Merge Duplicate Terms',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('term_merge_duplicates_form', 3),
    'access arguments' => array('merge terms'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['taxonomy/term/%taxonomy_term/merge'] = array(
    'title' => 'Merge Terms',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('term_merge_form', NULL, 2),
    'access arguments' => array('merge terms'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );

  $items['taxonomy/term/%taxonomy_term/merge/default'] = array(
    'title' => 'Default',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['taxonomy/term/%taxonomy_term/merge/duplicates'] = array(
    'title' => 'Merge Duplicate Terms',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('term_merge_duplicates_form', 2),
    'access arguments' => array('merge terms'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['term-merge/autocomplete/term-trunk/%taxonomy_vocabulary_machine_name'] = array(
    'title' => 'Autocomplete Term Merge form term trunk',
    'page callback' => 'term_merge_form_term_trunk_widget_autocomplete_autocomplete',
    'page arguments' => array(3),
    'access arguments' => array('merge terms'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function term_merge_admin_paths() {
  return array(
    'taxonomy/term/*/merge' => TRUE,
    'taxonomy/term/*/merge/*' => TRUE,
  );
}

/**
 * Implements hook_permission().
 */
function term_merge_permission() {
  return array(
    'merge terms' => array(
      'title' => t('Merge terms'),
      'description' => t('Gives the ability to merge taxonomy terms.'),
    ),
  );
}

/**
 * Implements hook_action_info().
 */
function term_merge_action_info() {
  return array(
    'term_merge_action' => array(
      'type' => 'taxonomy',
      'label' => t('Merge term'),
      'configurable' => TRUE,
      'behavior' => array('changes_property'),
    ),
  );
}

/**
 * Implements hook_help().
 */
function term_merge_help($path, $arg) {
  switch ($path) {
    // Main module help for the Term Merge module.
    case 'admin/help#term_merge':
      return '<p>' . t('Allows you to merge multiple terms into one and and at the same time update all fields referencing to the old ones.') . '</p>';
      break;
  }
}

/**
 * Generate the configuration form for action "Term merge".
 */
function term_merge_action_form($context) {
  $form = array();

  $form['displaimer'] = array(
    '#markup' => '<b>' . t('Sorry, currently Term Merge action is not supported via user interface. Please, contact the maintainers at the official website if you need it enabled via user interface.') . '</b>',
  );

  return $form;
}

/**
 * Form submission function.
 *
 * Store information about configurable action.
 */
function term_merge_action_submit($form, &$form_state) {
  // We don't have enabled UI for this action. It's just a dummy function.
  return array();
}

/**
 * Action function. Perform action "Term Merge".
 */
function term_merge_action($object, $context) {
  $term_branch = $object;
  $term_trunk = taxonomy_term_load($context['term_trunk']);
  $vocabulary = taxonomy_vocabulary_load($term_branch->vid);

  $term_branch_children = array();
  foreach (taxonomy_get_tree($term_branch->vid, $term_branch->tid) as $term) {
    $term_branch_children[] = $term->tid;
  }

  if ($term_branch->vid != $term_trunk->vid) {
    watchdog('term_merge', 'Trying to merge 2 terms (%term_branch, %term_trunk) from different vocabularies', array(
      '%term_branch' => $term_branch->name,
      '%term_trunk' => $term_trunk->name,
    ), WATCHDOG_WARNING);
    return;
  }
  if ($term_branch->tid == $term_trunk->tid) {
    watchdog('term_merge', 'Trying to merge a term %term into itself.', array('%term' => $term_branch->name), WATCHDOG_WARNING);
    return;
  }
  if (in_array($term_trunk->tid, $term_branch_children)) {
    watchdog('term_merge', 'Trying to merge a term %term_branch into its child %term_trunk.', array(
      '%term_branch' => $term_branch->name,
      '%term_trunk' => $term_trunk->name,
    ), WATCHDOG_WARNING);
    return;
  }

  // Defining some default values.
  if (!isset($context['term_branch_keep'])) {
    // It's easier to manually delete the unwanted terms, rather than
    // search for your DB back up. So by default we keep the term branch.
    $context['term_branch_keep'] = TRUE;
  }
  if (!isset($context['merge_fields'])) {
    // Initializing it with an empty array if client of this function forgot to
    // provide info about what fields to merge.
    $context['merge_fields'] = array();
  }
  if (!isset($context['keep_only_unique'])) {
    // Seems logical that mostly people will prefer to keep only one value in
    // term reference field per taxonomy term.
    $context['keep_only_unique'] = TRUE;
  }
  if (!isset($context['redirect']) || !module_exists('redirect')) {
    // This behavior requires Redirect module installed and enabled.
    $context['redirect'] = TERM_MERGE_NO_REDIRECT;
  }
  if (!isset($context['synonyms']) || !module_exists('synonyms')) {
    // This behavior requires Synonyms module installed and enabled.
    $context['synonyms'] = array();
  }

  // Calling a hook, this way we let whoever else to react and do his own extra
  // logic when merging of terms occurs. We prefer to call it before we handle
  // our own logic, because our logic might delete $term_branch and maybe a
  // module that implements this hook needs this term not deleted yet.
  module_invoke_all('term_merge', $term_trunk, $term_branch, $context);

  if (!empty($context['merge_fields'])) {
    // "Merging" the fields from $term_branch into $term_trunk where it is
    // possible.
    foreach ($context['merge_fields'] as $field_name) {
      // Getting the list of available languages for this field.
      $languages = array();
      if (isset($term_trunk->$field_name) && is_array($term_trunk->$field_name)) {
        $languages = array_merge($languages, array_keys($term_trunk->$field_name));
      }
      if (isset($term_branch->$field_name) && is_array($term_branch->$field_name)) {
        $languages = array_merge($languages, array_keys($term_branch->$field_name));
      }
      $languages = array_unique($languages);
      // Merging the data of both terms into $term_trunk.
      foreach ($languages as $language) {
        if (!isset($term_trunk->{$field_name}[$language])) {
          $term_trunk->{$field_name}[$language] = array();
        }
        if (!isset($term_branch->{$field_name}[$language])) {
          $term_branch->{$field_name}[$language] = array();
        }
        $term_trunk->{$field_name}[$language] = array_merge($term_trunk->{$field_name}[$language], $term_branch->{$field_name}[$language]);
      }
    }

    // And now we can save $term_trunk after shifting all the fields from
    // $term_branch.
    taxonomy_term_save($term_trunk);
  }

  // Updating all the links to $term_branch to point now to $term_trunk
  // firstly we go through the list of all fields searching for
  // taxonomy_term_reference field type because potentially some of these fields
  // values will have to be updated after merging terms.
  $fields = field_info_fields();
  $result = array();
  foreach ($fields as $k => $v) {
    // Additionally we group by field_name to know what field has to be updated
    // in each found entity.
    // @todo: Here would be nice to throw in a hook, allowing other modules to
    // supply meta data about their field types if they also use taxonomy
    // references, defining it in their own field types.
    if ($v['type'] == 'taxonomy_term_reference') {
      $result[$k] = array();
      $query = new EntityFieldQuery();
      // Making sure we search in the entire scope of entities.
      $query->addMetaData('account', user_load(1));
      $query->fieldCondition($v['field_name'], 'tid', $term_branch->tid);
      $_result = $query->execute();
      $result[$k] = array_merge_recursive($result[$k], $_result);
    }
  }
  // Now we load all entities that have taxonomy_term_reference pointing to
  // $term_branch.
  foreach ($result as $field_name => $entity_types) {
    foreach ($entity_types as $entity_type => $v) {
      $ids = array_keys($v);
      $entities = entity_load($entity_type, $ids);
      // After we have loaded it, we alter the taxonomy_term_reference
      // to point to $term_trunk.
      foreach ($entities as $entity) {
        // What is more, we have to do it for every available language.
        foreach ($entity->$field_name as $language => $items) {
          // Keeping track of whether term trunk is already present in this
          // field in this language. This is useful for the option
          // 'keep_only_unique'.
          $is_trunk_added = FALSE;
          foreach ($entity->{$field_name}[$language] as $delta => $item) {
            if ($context['keep_only_unique'] && $is_trunk_added && in_array($item['tid'], array($term_trunk->tid, $term_branch->tid))) {
              // We are instructed to keep only unique references and we already
              // have term trunk in this field, so we just unset value for this
              // delta.
              unset($entity->{$field_name}[$language][$delta]);
            }
            else {
              // Merging term references if necessary, and keep an eye on
              // whether we already have term trunk among this field values.
              switch ($item['tid']) {
                case $term_trunk->tid:
                  $is_trunk_added = TRUE;
                  break;

                case $term_branch->tid:
                  $is_trunk_added = TRUE;
                  $entity->{$field_name}[$language][$delta]['tid'] = $term_trunk->tid;
                  break;
              }
            }
          }
          // Above in the code, while looping through all deltas of this field,
          // we might have unset some of the deltas to keep term references
          // unique. We should better keep deltas as a serie of consecutive
          // numbers, because it is what it is supposed to be.
          $entity->{$field_name}[$language] = array_values($entity->{$field_name}[$language]);
        }
        // After updating all the references, save the entity.
        entity_save($entity_type, $entity);
      }
    }
  }

  // Adding term branch as synonym (Synonyms module integration).
  foreach ($context['synonyms'] as $synonym_field) {
    synonyms_add_entity_as_synonym($term_trunk, 'taxonomy_term', $synonym_field, $term_branch, 'taxonomy_term');
  }

  // It turned out we gotta go tricky with the Redirect module. If we create
  // redirection before deleting the branch term (if we are instructed to delete
  // in this action) redirect module will do its "auto-clean up" in
  // hook_entity_delete() and will delete our just created redirects. But at the
  // same time we have to get the path alias of the $term_branch before it gets
  // deleted. Otherwise the path alias will be deleted along with the term
  // itself.
  $redirect_paths = array();
  if ($context['redirect'] != TERM_MERGE_NO_REDIRECT) {
    // Creating HTTP redirect from term branch to the term trunk. We redirect
    // standard taxonomy/term/% path and optionally, if path alias is set, we
    // redirect from branch term path alias to the trunk term too.
    $alias = drupal_get_path_alias('taxonomy/term/' . $term_branch->tid);
    $redirect_paths[] = 'taxonomy/term/' . $term_branch->tid;
    if (!in_array($alias, $redirect_paths)) {
      $redirect_paths[] = $alias;
    }
  }

  if (!$context['term_branch_keep']) {
    // If we are going to delete branch term, we need firstly to make sure
    // all its children now have the parent of term_trunk.
    foreach (taxonomy_get_children($term_branch->tid, $vocabulary->vid) as $child) {
      $parents = taxonomy_get_parents($child->tid);
      // Deleting the parental link to the term that is being merged.
      unset($parents[$term_branch->tid]);
      // And putting the parental link to the term that we merge into.
      $parents[$term_trunk->tid] = $term_trunk;
      $parents = array_unique(array_keys($parents));
      $child->parent = $parents;
      taxonomy_term_save($child);
    }

    // Views module integration. We update all Views taxonomy filter handlers
    // configured to filter on term branch to filter on term trunk now, since
    // the former becomes the latter.
    if (module_exists('views')) {
      $views = views_get_all_views();
      foreach ($views as $view) {
        // For better efficiency, we keep track of whether we have updated
        // anything in a view, and thus whether we need to save it.
        $needs_saving = FALSE;
        // Even worse, we have to go through each display of each view.
        foreach ($view->display as $display_id => $display) {
          $view->set_display($display_id);
          $filters = $view->display_handler->get_handlers('filter');
          foreach ($filters as $filter_id => $filter_handler) {
            // Currently we know how to update filters only of this particular
            // class.
            if (get_class($filter_handler) == 'views_handler_filter_term_node_tid') {
              $filter = $view->get_item($display_id, 'filter', $filter_id);
              if (isset($filter['value'][$term_branch->tid])) {
                // Substituting term branch with term trunk.
                unset($filter['value'][$term_branch->tid]);
                $filter['value'][$term_trunk->tid] = $term_trunk->tid;
                $view->set_item($display_id, 'filter', $filter_id, $filter);
                $needs_saving = TRUE;
              }
            }
          }
        }
        if ($needs_saving) {
          $view->save();
        }
      }
    }

    // We are instructed to delete the term branch after the merge,
    // and so we do.
    taxonomy_term_delete($term_branch->tid);
  }

  // Here we do the 2nd part of integraiton with the Redirect module. Once the
  // branch term has been deleted (if deleted), we can add the redirects
  // without being afraid that the redirect module will delete them in its
  // hook_entity_delete().
  foreach ($redirect_paths as $v) {
    $redirect = new stdClass();
    redirect_object_prepare($redirect, array(
      'source' => $v,
      'redirect' => drupal_get_path_alias('taxonomy/term/' . $term_trunk->tid),
      'status_code' => $context['redirect'],
    ));
    redirect_save($redirect);
  }

  watchdog('term_merge', 'Successfully merged term %term_branch into term %term_trunk in vocabulary %vocabulary. Context: @context', array(
    '%term_branch' => $term_branch->name,
    '%term_trunk' => $term_trunk->name,
    '%vocabulary' => $vocabulary->name,
    '@context' => var_export($context, 1),
  ));
}

/**
 * Menu callback.
 *
 * Allow user to specify which terms to be merged into which term and any
 * other settings needed for the term merge action.
 *
 * @param object $vocabulary
 *   Fully loaded taxonomy vocabulary object
 * @param object $term
 *   Fully loaded taxonomy term object that should be selected as the default
 *   merge term in the form. If the $vocabulary is omitted, the vocabulary of
 *   $term is considered
 *
 * @return array
 *   Array of the form in Form API format
 */
function term_merge_form($form, $form_state, $vocabulary = NULL, $term = NULL) {
  if (is_null($vocabulary)) {
    $vocabulary = taxonomy_vocabulary_load($term->vid);
  }

  // It's always handy to have the vocabulary by hand.
  $form['#vocabulary'] = $vocabulary;

  if (!isset($form_state['storage']['confirm'])) {
    // We are at the set up step.

    $term_branch_value = is_null($term) ? NULL : array($term->tid);
    if (variable_get('taxonomy_override_selector', FALSE) && module_exists('hs_taxonomy')) {
      // We use Hierarchical Select module if it's available and configured to
      // be used for taxonomy selects.
      $form['term_branch'] = array(
        '#type' => 'hierarchical_select',
        // @todo: firgure out why #required => TRUE doesn't work.
        // As a matter of fact, this issue seems to cover our case.
        // http://drupal.org/node/1275862.
        //'#required' => TRUE,
        '#config' => array(
          'module' => 'hs_taxonomy',
          'params' => array(
            'vid' => $vocabulary->vid,
            'exclude_tid' => NULL,
            'root_term'   => FALSE,
          ),
          'enforce_deepest' => 0,
          'entity_count' => 0,
          'require_entity' => 0,
          'save_lineage' => 0,
          'level_labels' => array(
            'status' => 0,
          ),
          'dropbox' => array(
            'status' => 1,
            'limit' => 0,
          ),
          'editability' => array(
            'status' => 0,
          ),
          'resizable' => TRUE,
          'render_flat_select' => 0,
        ),
      );
    }
    else {
      // Falling back on a simple <select>.
      $tree = taxonomy_get_tree($vocabulary->vid);
      $options = array();
      foreach ($tree as $k => $v) {
        $options[$v->tid] = str_repeat('-', $v->depth) . $v->name;
        // Additionally we key the $tree by term->tid.
        unset($tree[$k]);
        $tree[$v->tid] = $v;
      }
      $form['term_branch'] = array(
        '#type' => 'select',
        '#required' => TRUE,
        '#multiple' => TRUE,
        '#options' => $options,
        '#size' => 8,
      );
    }

    $form['term_branch'] = array(
      '#title' => t('Terms to Merge'),
      '#description' => t('Please, choose the terms you want to merge into another term.'),
      '#ajax' => array(
        'callback' => 'term_merge_form_term_trunk',
        'wrapper' => 'term-merge-form-term-trunk',
        'method' => 'replace',
        'effect' => 'fade',
      ),
      '#default_value' => $term_branch_value,
    ) + $form['term_branch'];
    if (is_null($form['term_branch']['#default_value'])) {
      unset($form['term_branch']['#default_value']);
    }

    $form['term_trunk'] = array(
      '#type' => 'fieldset',
      '#title' => t('Merge Into'),
      '#prefix' => '<div id="term-merge-form-term-trunk">',
      '#suffix' => '</div>',
      '#tree' => TRUE,
    );

    // Array of currently available widgets for choosing term trunk.
    $term_trunk_widget_options = array(
      'autocomplete' => 'Autocomplete',
    );
    if (variable_get('taxonomy_override_selector', FALSE) && module_exists('hs_taxonomy')) {
      $term_trunk_widget_options['hs_taxonomy'] = t('Hierarchical Select');
      $term_trunk_widget = 'hs_taxonomy';
    }
    else {
      $term_trunk_widget_options['select'] = t('Select');
      $term_trunk_widget = 'select';
    }

    // Override the term trunk widget if settings are found in $form_state.
    if (isset($form_state['values']['term_trunk']['widget']) && in_array($form_state['values']['term_trunk']['widget'], array_keys($term_trunk_widget_options))) {
      $term_trunk_widget = $form_state['values']['term_trunk']['widget'];
    }

    $form['term_trunk']['widget'] = array(
      '#type' => 'radios',
      '#title' => t('Widget'),
      '#required' => TRUE,
      '#options' => $term_trunk_widget_options,
      '#default_value' => $term_trunk_widget,
      '#description' => t('Please, choose what widget you prefer for entering the term trunk. Note, in autocomplete widget you will not have an option for creating a new term and then it using as the term trunk.'),
      '#ajax' => array(
        'callback' => 'term_merge_form_term_trunk',
        'wrapper' => 'term-merge-form-term-trunk',
        'method' => 'replace',
        'effect' => 'fade',
      ),
    );

    // @todo:
    // There is a known bug, if user has selected something in one widget, and
    // then changes the widget, $form_states['values'] will hold the value for
    // term trunk form element in the format that is used in one widget, while
    // this value will be passed to another widget. This triggers different
    // unpleasant effects like showing tid instead of term's name or vice-versa.
    // I think we should just empty $form_state['values'] for the term trunk
    // form element when widget changes. Better ideas are welcome!
    switch ($term_trunk_widget) {
      case 'select':
        term_merge_form_term_trunk_widget_select($form, $form_state, $vocabulary);
        break;

      case 'autocomplete':
        term_merge_form_term_trunk_widget_autocomplete($form, $form_state, $vocabulary);
        break;

      case 'hs_taxonomy':
        term_merge_form_term_trunk_widget_hs_taxonomy($form, $form_state, $vocabulary);
        break;
    }
    // Ensuring the Merge Into form element has the same title no matter what
    // widget has been used.
    $form['term_trunk']['tid']['#title'] = t('Merge into');

    // Adding necessary options of merging.
    $form += term_merge_merge_options_elements($vocabulary);

    $form['actions'] = array(
      '#type' => 'actions',
    );

    $form['actions']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Submit'),
    );
  }
  else {
    // We are at the confirmation step.
    $count = count($form_state['values']['term_branch']);
    $question = format_plural($count, 'Are you sure want to merge 1 term?', 'Are you sure want to merge @count terms?');
    $form = confirm_form($form, $question, 'admin/structure/taxonomy/' . $vocabulary->machine_name);
  }

  return $form;
}

/**
 * Supportive function.
 *
 * Validate the term_merge_form(). Make sure term trunk is not among the
 * selected term branches or their children.
 */
function term_merge_form_validate($form, &$form_state) {
  if (!isset($form_state['storage']['confirm'])) {
    // We only validate the 1st step of the form.
    $prohibited_trunks = array();
    foreach ($form_state['values']['term_branch'] as $term_branch) {
      $children = taxonomy_get_tree($form['#vocabulary']->vid, $term_branch);
      $prohibited_trunks[] = $term_branch;
      foreach ($children as $child) {
        $prohibited_trunks[] = $child->tid;
      }
    }
    if (in_array($form_state['values']['term_trunk']['tid'], $prohibited_trunks)) {
      form_error($form['term_trunk']['tid'], t('Trunk term cannot be one of the selected branch terms or their children.'));
    }
  }
}

/**
 * Submit handler for term_merge_form(). Merge terms one into another.
 */
function term_merge_form_submit($form, &$form_state) {
  if (!isset($form_state['storage']['confirm'])) {
    // Since merging terms is an important operation, we better confirm user
    // really wants to do this.
    $form_state['storage']['confirm'] = 0;
    $form_state['rebuild'] = TRUE;

    // Before storing the submitted values we slightly preprocess them to make
    // sure they correspond to what is expected by submit handler of taxonomy
    // creation form.
    if (isset($form_state['values']['relations'])) {
      $form_state['values'] += $form_state['values']['relations'];
    }
    $form_state['storage']['info'] = $form_state['values'];
    $form_state['storage']['merge_settings'] = term_merge_merge_options_submit($form, $form_state, $form);
    $form_state['storage']['old_form'] = $form;
  }
  else {
    // The user has confirmed merging. We pull up the submitted values.
    $form_state['values'] = $form_state['storage']['info'];

    // If necessary, create the term trunk.
    if ($form_state['values']['term_trunk']['tid'] == TERM_MERGE_NEW_TERM_TRUNK) {
      // We try to mimic normal form submission for taxonomy module.
      module_load_include('inc', 'taxonomy', 'taxonomy.admin');
      taxonomy_form_term_submit($form_state['storage']['old_form']['term_trunk']['term_create'], $form_state);
      $term_trunk = $form_state['term'];
    }
    else {
      $term_trunk = taxonomy_term_load($form_state['values']['term_trunk']['tid']);
    }

    term_merge(array_values($form_state['values']['term_branch']), $term_trunk->tid, $form_state['storage']['merge_settings']);

    $form_state['redirect'] = array('admin/structure/taxonomy/' . $term_trunk->vocabulary_machine_name);
  }
}

/**
 * Supportive function.
 *
 * Generate form elements for select widget for term trunk element of the
 * term_merge_form().
 *
 * @param object $vocabulary
 *   Fully loaded taxonomy vocabulary object
 */
function term_merge_form_term_trunk_widget_select(&$form, &$form_state, $vocabulary) {
  $tree = taxonomy_get_tree($vocabulary->vid);
  $options = array();
  foreach ($tree as $k => $v) {
    $options[$v->tid] = str_repeat('-', $v->depth) . $v->name;
    // Additionally we key the $tree by term->tid.
    unset($tree[$k]);
    $tree[$v->tid] = $v;
  }

  $term_branch_value = array();
  // Firstly trying to look up selected term branches in the default value of
  // term branch form element.
  if (isset($form['term_branch']['#default_value']) && is_array($form['term_branch']['#default_value'])) {
    $term_branch_value = $form['term_branch']['#default_value'];
  }
  if (isset($form_state['values']['term_branch']) && is_array($form_state['values']['term_branch'])) {
    $term_branch_value = $form_state['values']['term_branch'];
  }

  if (!empty($term_branch_value)) {
    // We have to make sure among term_trunk there is no term_branch or any of
    // their children.
    foreach ($term_branch_value as $v) {
      unset($options[$v]);
      foreach (taxonomy_get_tree($vocabulary->vid, $v) as $child) {
        unset($options[$child->tid]);
      }
    }
    $options = array(TERM_MERGE_NEW_TERM_TRUNK => 'New Term') + $options;
  }
  else {
    // Term branch has not been selected yet.
    $options = array();
  }

  $form['term_trunk']['tid'] = array(
    '#type' => 'select',
    '#required' => TRUE,
    '#description' => t('Please, choose into what term you want to merge.'),
    '#options' => $options,
    '#ajax' => array(
      'callback' => 'term_merge_form_term_trunk_term_create',
      'wrapper' => 'term-merge-form-term-trunk-term-create',
      'method' => 'replace',
      'effect' => 'fade',
    ),
  );

  $form['term_trunk']['term_create'] = array(
    '#prefix' => '<div id="term-merge-form-term-trunk-term-create">',
    '#suffix' => '</div>',
  );
  // We throw in the Taxonomy native term create form only if the option for
  // creation of a new term was selected by user.
  if (isset($form_state['values']['term_trunk']['tid']) && $form_state['values']['term_trunk']['tid'] == TERM_MERGE_NEW_TERM_TRUNK) {
    module_load_include('inc', 'taxonomy', 'taxonomy.admin');

    $form['term_trunk']['term_create'] += array(
      '#type' => 'fieldset',
      '#title' => t('Create New Term'),
    );

    $form['term_trunk']['term_create'] += taxonomy_form_term($form['term_trunk']['term_create'], $form_state, array(), $vocabulary);
    // We have our own submit button, so we unset the normal one from the term
    // create form.
    unset($form['term_trunk']['term_create']['actions']);
    // Additionally we have to filter out from "Parent Terms" select the already
    // selected branch terms and their children, because we can't merge into
    // the term itself or its children.
    // We do a trick here, since we know the 1st element is the <root> option
    // and all others are normal taxonomy terms, we keep the 1st element as it
    // is while all the other elements we substitute with our $options array
    // which is basically identical but already has been filtered out unwanted
    // terms. Plus we have to unset the 'New Term' option from $options.
    unset($options[TERM_MERGE_NEW_TERM_TRUNK]);
    if (is_array($form['term_trunk']['term_create']['relations']['parent']['#options'])) {
      $form['term_trunk']['term_create']['relations']['parent']['#options'] = array_slice($form['term_trunk']['term_create']['relations']['parent']['#options'], 0, 1, TRUE) + $options;
    }

    // For each field attached to taxonomy term of this vocabualry that has
    // unlimited cardinality we have to extra process the results, otherwise
    // "Add another item" button doesn't work.
    $instances = field_info_instances($form['term_trunk']['term_create']['#entity_type'], $form['term_trunk']['term_create']['#bundle']);
    foreach ($instances as $instance) {
      $field = field_info_field($instance['field_name']);
      if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED) {
        if (isset($form['term_trunk']['term_create'][$field['field_name']][LANGUAGE_NONE]['add_more']['#limit_validation_errors'])) {
          $form['term_trunk']['term_create'][$field['field_name']][LANGUAGE_NONE]['add_more']['#limit_validation_errors'] = array(array('term_branch'), array('term_trunk'));
        }
      }
    }
  }
}

/**
 * Supportive function.
 *
 * Generate form elements for autocomplete widget for term trunk element of the
 * term_merge_form().
 *
 * @param object $vocabulary
 *   Fully loaded taxonomy vocabulary object
 */
function term_merge_form_term_trunk_widget_autocomplete(&$form, &$form_state, $vocabulary) {
  $form['term_trunk']['tid'] = array(
    '#type' => 'textfield',
    '#description' => t("Start typing in a term's name in order to get some suggestions."),
    '#required' => TRUE,
    '#autocomplete_path' => 'term-merge/autocomplete/term-trunk/' . $vocabulary->machine_name,
    '#element_validate' => array('term_merge_form_trunk_term_widget_autocomplete_validate'),
  );
}

/**
 * Supportive function.
 *
 * Generate form element for hierarchical select widget for term trunk element
 * of the term_merge_form().
 *
 * @param object $vocabulary
 *   Fully loaded taxonomy vocabulary object
 */
function term_merge_form_term_trunk_widget_hs_taxonomy(&$form, &$form_state, $vocabulary) {
  $form['term_trunk']['tid'] = array(
    '#type' => 'hierarchical_select',
    '#description' => t('Please select a term to merge into.'),
    '#required' => TRUE,
    '#element_validate' => array('term_merge_form_trunk_term_widget_hs_taxonomy_validate'),
    '#config' => array(
      'module' => 'hs_taxonomy',
      'params' => array(
        'vid' => $vocabulary->vid,
        'exclude_tid' => NULL,
        'root_term'   => FALSE,
      ),
      'enforce_deepest' => 0,
      'entity_count' => 0,
      'require_entity' => 0,
      'save_lineage' => 0,
      'level_labels' => array(
        'status' => 0,
      ),
      'dropbox' => array(
        'status' => 0,
      ),
      'editability' => array(
        'status' => 0,
      ),
      'resizable' => TRUE,
      'render_flat_select' => 0,
    ),
  );
}

/**
 * Supportive function.
 *
 * Validate form element of the autocomplete widget of term trunk element of
 * the form term_merge_form(). Make sure the enetered string is a name of one of
 * the existing terms in the vocabulary where the merge occurs. If term is found
 * the function substitutes the name with its {taxonomy_term_data}.tid as it is
 * what is expected from a term trunk widget to provide in its value.
 */
function term_merge_form_trunk_term_widget_autocomplete_validate($element, &$form_state, $form) {
  $term = taxonomy_get_term_by_name($element['#value'], $form['#vocabulary']->machine_name);
  if (!is_array($term) || empty($term)) {
    // Seems like the user has entered a non existing name in the autocomplete
    // textfield.
    form_error($element, t('There are no terms with name %name in the %vocabulary vocabulary.', array(
      '%name' => $element['#value'],
      '%vocabulary' => $form['#vocabulary']->name,
    )));
  }
  else {
    // We have to substitute the term's name with its tid in order to make this
    // widget consistent with the interface.
    $term = array_pop($term);
    form_set_value($element, $term->tid, $form_state);
  }
}

/**
 * Supportive function.
 *
 * Validate form element of the Hierarchical Select widget of term trunk element
 * of the form term_merge_form(). Convert the value from array to a single tid
 * integer value.
 */
function term_merge_form_trunk_term_widget_hs_taxonomy_validate($element, &$form_state, $form) {
  $tid = 0;
  if (is_array($element['#value']) && !empty($element['#value'])) {
    $tid = (int) array_pop($element['#value']);
  }
  form_set_value($element, $tid, $form_state);
}

/**
 * Menu page callback function.
 *
 * Autocomplete callback function for the trunk term form element in the widget
 * of autocomplete. The code of this function was mainly copy-pasted from
 * Taxonomy autocomplete widget menu callback function.
 *
 * @param object $vocabulary
 *   Fully loaded vocabulary object inside of which the terms are about to be
 *   merged
 */
function term_merge_form_term_trunk_widget_autocomplete_autocomplete($vocabulary) {
  // If the request has a '/' in the search text, then the menu system will have
  // split it into multiple arguments, recover the intended $tags_typed.
  $args = func_get_args();
  // Shift off the $vocabulary argument.
  array_shift($args);
  $tags_typed = implode('/', $args);

  // Querying database for suggestions.
  $query = db_select('taxonomy_term_data', 't');
  $tags_return = $query->addTag('translatable')
    ->addTag('term_access')
    ->fields('t', array('tid', 'name'))
    ->condition('t.vid', $vocabulary->vid)
    ->condition('t.name', '%' . db_like($tags_typed) . '%', 'LIKE')
    ->range(0, 10)
    ->execute()
    ->fetchAllKeyed();

  $term_matches = array();
  foreach ($tags_return as $name) {
    $n = $name;
    // Term names containing commas or quotes must be wrapped in quotes.
    if (strpos($name, ',') !== FALSE || strpos($name, '"') !== FALSE) {
      $n = '"' . str_replace('"', '""', $name) . '"';
    }
    $term_matches[$n] = check_plain($name);
  }

  drupal_json_output($term_matches);
}

/**
 * Ajax callback function.
 *
 * Used in term_merge_term_merge_form() to replace the term_trunk element
 * depending on already selected term_branch values.
 */
function term_merge_form_term_trunk($form, $form_state) {
  return $form['term_trunk'];
}

/**
 * Ajax callback function.
 *
 * Used in term_merge_term_merge_form() to replace the term create fieldset
 * depending on already selected term_branch values and the term_trunk value.
 */
function term_merge_form_term_trunk_term_create($form, $form_state) {
  return $form['term_trunk']['term_create'];
}

/**
 * Merge terms one into another using batch API.
 *
 * @param array $term_branch
 *   A single term tid or an array of term tids to be merged, aka term branches
 * @param int $term_trunk
 *   The tid of the term to merge term branches into, aka term trunk
 * @param array $merge_settings
 *   Array of settings that control how merging should happen. Currently
 *   supported settings are:
 *     - term_branch_keep: (bool) Whether the term branches should not be
 *       deleted, also known as "merge only occurrences" option
 *     - merge_fields: (array) Array of field names whose values should be
 *       merged into the values of corresponding fields of term trunk (until
 *       each field's cardinality limit is reached)
 *     - keep_only_unique: (bool) Whether after merging within one field only
 *       unique taxonomy term references should be kept in other entities. If
 *       before merging your entity had 2 values in its taxonomy term reference
 *       field and one was pointing to term branch while another was pointing to
 *       term trunk, after merging you will end up having your entity
 *       referencing to the same term trunk twice. If you pass TRUE in this
 *       parameter, only a single reference will be stored in your entity after
 *       merging
 *     - redirect: (int) HTTP code for redirect from $term_branch to
 *       $term_trunk, 0 stands for the default redirect defined in Redirect
 *       module. Use constant TERM_MERGE_NO_REDIRECT to denote not creating any
 *       HTTP redirect. Note: this parameter requires Redirect module enabled,
 *       otherwise it will be disregarded
 *     - synonyms: (array) Array of field names of trunk term into which branch
 *       terms should be added as synonyms (until each field's cardinality limit
 *       is reached). Note: this parameter requires Synonyms module enabled,
 *       otherwise it will be disregarded
 *     - step: (int) How many term branches to merge per script run in batch. If
 *       you are hitting time or memory limits, decrease this parameter
 */
function term_merge($term_branch, $term_trunk, $merge_settings = array()) {
  // Older versions of this module had another interface of this function,
  // as backword capability we still support the older interface, instead of
  // supplying a $merge_settings array, it was supplying all the settings as
  // additional function arguments.
  // @todo: delete this backword capability at some point.
  if (!is_array($merge_settings)) {
    $merge_settings = array(
      'term_branch_keep' => $merge_settings,
    );
  }

  // Create an array of sources if it isn't yet.
  if (!is_array($term_branch)) {
    $term_branch = array($term_branch);
  }

  // Creating a skeleton for the merging batch.
  $batch = array(
    'title' => t('Merging terms'),
    'operations' => array(
      array('_term_merge_batch_process', array(
        $term_branch,
        $term_trunk,
        $merge_settings,
      )),
    ),
    'finished' => 'term_merge_batch_finished',
  );

  // Initialize the batch process.
  batch_set($batch);
}

/**
 * Process batch function.
 *
 * Trigger action 'term_merge_action' on each pair of term branch:term trunk.
 *
 * @param array $term_branch
 *   An array of term tids to be merged, aka term branches
 * @param int $term_trunk
 *   The tid of the term to merge term branches into, aka term trunk
 * @param array $merge_settings
 *   Array of settings that control how merging should happen. Currently
 *   supported settings are:
 *     - term_branch_keep: (bool) Whether the term branches should not be
 *       deleted, also known as "merge only occurrences" option
 *     - merge_fields: (array) Array of field names whose values should be
 *       merged into the values of corresponding fields of term trunk (until
 *       each field's cardinality limit is reached)
 *     - keep_only_unique: (bool) Whether after merging within one field only
 *       unique taxonomy term references should be kept in other entities. If
 *       before merging your entity had 2 values in its taxonomy term reference
 *       field and one was pointing to term branch while another was pointing to
 *       term trunk, after merging you will end up having your entity
 *       referencing to the same term trunk twice. If you pass TRUE in this
 *       parameter, only a single reference will be stored in your entity after
 *       merging
 *     - redirect: (int) HTTP code for redirect from $term_branch to
 *       $term_trunk, 0 stands for the default redirect defined in Redirect
 *       module. Use constant TERM_MERGE_NO_REDIRECT to denote not creating any
 *       HTTP redirect. Note: this parameter requires Redirect module enabled,
 *       otherwise it will be disregarded
 *     - synonyms: (array) Array of field names of trunk term into which branch
 *       terms should be added as synonyms (until each field's cardinality limit
 *       is reached). Note: this parameter requires Synonyms module enabled,
 *       otherwise it will be disregarded
 *     - step: (int) How many term branches to merge per script run in batch. If
 *       you are hitting time or memory limits, decrease this parameter
 * @param array $context
 *   Drupal Batch API context array
 */
function _term_merge_batch_process($term_branch, $term_trunk, $merge_settings, &$context) {
  // Initializing sandbox.
  if (!isset($context['sandbox']['current'])) {
    $context['sandbox']['current'] = 0;
  }

  // Populating $merge_settings with defaults.
  $merge_settings += array(
    'term_branch_keep' => FALSE,
    'merge_fields' => array(),
    'keep_only_unique' => TRUE,
    'redirect' => TERM_MERGE_NO_REDIRECT,
    'synonyms' => array(),
    'step' => 40,
  );

  $total = count($term_branch);
  // To speed up the process we take advantage of taxonomy_term_load_multiple()
  // instead of just repeating calls to taxonomy_term_load().
  $till = min($total, $context['sandbox']['current'] + $merge_settings['step']);
  $length = $till - $context['sandbox']['current'];
  $term_branch = array_slice($term_branch, $context['sandbox']['current'], $length);
  $term_branch = array_values(taxonomy_term_load_multiple($term_branch));
  for ($i = 0; $i < $merge_settings['step'] && $context['sandbox']['current'] < $total; $i++) {
    actions_do('term_merge_action', $term_branch[$i], array(
      'term_trunk' => $term_trunk,
      'term_branch_keep' => $merge_settings['term_branch_keep'],
      'merge_fields' => $merge_settings['merge_fields'],
      'keep_only_unique' => $merge_settings['keep_only_unique'],
      'redirect' => $merge_settings['redirect'],
      'synonyms' => $merge_settings['synonyms'],
    ));
    $context['sandbox']['current']++;
  }

  if ($context['sandbox']['current'] != $total) {
    $context['finished'] = $context['sandbox']['current'] / $total;
    $term = $term_branch[$i - 1];
    $context['message'] = t('Merged up to @term', array('@term' => $term->name));
  }
}

/**
 * Batch 'finished' callback.
 *
 * Process results of Term Merge batch.
 */
function term_merge_batch_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('The terms have been successfully merged.'));
  }
  else {
    // An error happened. We have to notify the user.
    drupal_set_message(t('An error occurred. We are sorry, please, report this error to the maintainers of Term Merge module.'), 'error');
  }
}

/**
 * Generate 'term_merge_duplicates_form'.
 *
 * Allow merging terms with the same or similar names.
 *
 * @param object $vocabulary
 *   Fully loaded taxonomy vocabulary object inside of which term merging occurs
 *   or fully loaded taxonomy term object using which the function will pull up
 *   the vocabulary inside of which term merging occurs
 */
function term_merge_duplicates_form($form, &$form_state, $vocabulary) {
  // Checking if we were given vocabulary object, or term object.
  if (isset($vocabulary->tid)) {
    // It's term object, we have to substitute it with a vocabulary object.
    $vocabulary = taxonomy_vocabulary_load($vocabulary->vid);
  }
  $tree = taxonomy_get_tree($vocabulary->vid);

  // Helpful and self explaining text that should help people understand what's
  // up.
  $form['help'] = array(
    '#markup' => '<p>' . t('Here you can merge terms with the same names. It is a useful tool against term-duplicates. The terms are grouped by names. Term into which the merging will occur is selected manually by user, however you must know that it is impossible to merge a parent term into any of its children. Each group consists of a table of found duplicates. Tick on the terms you would like to merge and choose the term into which you want to merge the ticked on terms.') . '</p>',
  );

  // Array of groups of terms with the same name. Each group is an array of
  // duplicates. Trunk term of each group will be chosen by user.
  $groups = array();
  foreach ($tree as $term) {
    $name = term_merge_duplicates_process_name($term->name);
    if (!isset($groups[$name])) {
      $groups[$name] = array();
    }
    $groups[$name][] = $term;
  }

  $form['group'] = array(
    '#tree' => TRUE,
  );
  // Whether there is at least one group of possible duplicate terms found.
  $is_any = FALSE;

  foreach ($groups as $i => $group) {
    if (count($group) > 1) {
      $is_any = TRUE;

      $form['group'][$i] = array(
        '#type' => 'fieldset',
        '#title' => $group[0]->name,
        '#collapsible' => TRUE,
        '#pre_render' => array('term_merge_duplicates_fieldset_preprocess'),
        '#element_validate' => array('term_merge_duplicates_fieldset_validate'),
      );

      $options = array();
      foreach ($group as $term) {
        $parents = array();
        foreach (taxonomy_get_parents_all($term->tid) as $parent) {
          // We do not include the current term in the hierarchy.
          if ($parent->tid != $term->tid) {
            $parents[] = $parent->name;
          }
        }
        // Adding Root to the hierarchy.
        $parents[] = t('Vocabulary Root');
        $options[$term->tid] = array(
          'id' => $term->tid,
          'title' => l($term->name, 'taxonomy/term/' . $term->tid),
          'description' => check_markup($term->description, $term->format),
          'parents' => implode(' &raquo; ', $parents),
        );
      }

      $form['group'][$i]['duplicates'] = array(
        '#type' => 'tableselect',
        '#title' => 'Duplicates',
        '#header' => array(
          'id' => t('ID'),
          'title' => t('Title'),
          'description' => t('Description'),
          'parents' => t('Parents'),
        ),
        '#options' => $options,
      );

      $options = array();
      foreach ($group as $term) {
        $options[$term->tid] = $term->name;
      }
      $form['group'][$i]['trunk_tid'] = array(
        '#type' => 'radios',
        '#title' => t('Merge Into'),
        '#options' => $options,
      );
    }
  }

  if ($is_any) {
    // Adding necessary options of merging.
    $form += term_merge_merge_options_elements($vocabulary);

    $form['actions'] = array(
      '#type' => 'actions',
    );

    $form['actions']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Submit'),
    );
  }
  else {
    $form['nothing_found'] = array(
      '#markup' => '<p><b>' . t('Sorry, seems like we were not able to find any possible duplicate terms in %vocabulary vocabulary.', array(
        '%vocabulary' => $vocabulary->name,
      )) . '</b></p>',
    );
  }

  return $form;
}

/**
 * Submit handler for 'term_merge_duplicates_form'.
 *
 * Actually merge duplicate terms.
 */
function term_merge_duplicates_form_submit($form, &$form_state) {
  $batch = array(
    'title' => t('Merging terms'),
    'operations' => array(),
    'finished' => 'term_merge_batch_finished',
  );

  // Processing general options for merging.
  $merge_settings = term_merge_merge_options_submit($form, $form_state, $form);

  if (isset($form_state['values']['group'])) {
    foreach ($form_state['values']['group'] as $values) {
      // Filtering out only the selected duplicate terms.
      $term_branches = array_filter($values['duplicates']);
      if (!empty($term_branches)) {
        // If something has been selected in this group we schedule its merging.
        $batch['operations'][] = array('_term_merge_batch_process', array(
            $term_branches,
            $values['trunk_tid'],
            $merge_settings,
          ),
        );
      }
    }
  }

  if (empty($batch['operations'])) {
    drupal_set_message(t('No merging has been made, because you have not selected any duplicate term to merge.'));
  }
  else {
    batch_set($batch);
  }
}

/**
 * String process function.
 *
 * Manipulate supplied var $name and by the output of this function terms in a
 * vocabulary are grouped as duplicates.
 *
 * @param string $name
 *   String that needs to be manipulated
 *
 * @return string
 *   Processed string (normally it implies making it upper case, stripping down
 *   any special chars, etc.)
 */
function term_merge_duplicates_process_name($name) {
  // Making upper case.
  $name = drupal_strtoupper($name);
  // Trying transliteration, if available.
  if (module_exists('transliteration')) {
    $name = transliteration_get($name);
    // Keeping only ASCII chars.
    $name = preg_replace('#\W#', '', $name);
  }
  return $name;
}

/**
 * Form element preprocess function.
 *
 * Insert extra column for choosing term trunk into tableselect of terms to be
 * merged.
 */
function term_merge_duplicates_fieldset_preprocess($element) {
  $options = &$element['duplicates']['#options'];
  foreach ($options as $tid => $row) {
    $element['trunk_tid'][$tid]['#title_display'] = 'invisible';
    $options[$tid] = array(
      'trunk' => drupal_render($element['trunk_tid'][$tid]),
    ) + $options[$tid];
  }
  $element['trunk_tid']['#title_display'] = 'invisble';
  $element['duplicates']['#header'] = array(
    'trunk' => $element['trunk_tid']['#title'],
  ) + $element['duplicates']['#header'];

  return $element;
}

/**
 * FAPI element validation callback.
 *
 * Validate fieldset of a 'term_merge_duplicates_form' form, if any duplicate
 * has been selected for merging, it makes sure the trunk term has been
 * selected. We can't allow merging without knowing the explicit trunk term.
 */
function term_merge_duplicates_fieldset_validate($element, &$form_state, $form) {
  if (!empty($element['duplicates']['#value']) && !is_numeric($element['trunk_tid']['#value'])) {
    form_error($element, t('Please, choose %trunk_tid_label for the group %group_label', array(
      '%trunk_tid_label' => $element['trunk_tid']['#title'],
      '%group_label' => $element['#title'],
    )));
  }
}

/**
 * Generate and return form elements that control behavior of merge action.
 *
 * Output of this function should be used in any form that merges terms,
 * ensuring unified interface. It should be used in conjunction with
 * term_merge_merge_options_submit(), which will process the submitted values
 * for you and return an array of merge settings.
 *
 * @param object $vocabulary
 *   Fully loaded taxonomy vocabulary object in which merging occurs
 *
 * @return array
 *   Array of form elements that allow controlling term merge action
 *
 * @see term_merge_merge_options_submit()
 */
function term_merge_merge_options_elements($vocabulary) {
  // @todo: it would be nice to provide some ability to supply default values
  // for each setting.
  $form = array();

  // Getting bundle name and a list of fields attached to this bundle for
  // further use down below in the code while generating form elements.
  $bundle = field_extract_bundle('taxonomy_term', $vocabulary);
  $instances = field_info_instances('taxonomy_term', $bundle);

  $form['term_branch_keep'] = array(
    '#type' => 'checkbox',
    '#title' => t('Only merge occurrences'),
    '#description' => t('Check this if you want to only merge the occurrences of the specified terms, i.e. the terms will not be deleted from your vocabulary.'),
  );

  $options = array();
  foreach ($instances as $instance) {
    $options[$instance['field_name']] = $instance['label'];
  }
  $form['merge_fields'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Merge Term Fields'),
    '#description' => t('Check the fields whose values from brach terms you want to add to the values of corresponding fields of the trunk term. <b>Important note:</b> the values will be added until the cardinality limit for the selected fields is reached.'),
    '#options' => $options,
  );

  $form['keep_only_unique'] = array(
    '#type' => 'checkbox',
    '#title' => t('Keep only unique terms after merging'),
    '#description' => t('Sometimes after merging you may end up having a node (or any other entity) pointing twice to the same taxonomy term, tick this checkbox if want to keep only unique terms in other entities after merging.'),
  );

  if (module_exists('redirect')) {
    $options = array(TERM_MERGE_NO_REDIRECT => 'No redirect') + array(
      0 => t('Default (@default)',
        array('@default' => variable_get('redirect_default_status_code', 301))),
    ) + redirect_status_code_options();
    $form['redirect'] = array(
      // We respect access rights defined in redirect.module here.
      '#access' => user_access('administer redirects'),
      '#type' => 'select',
      '#title' => t('Create Redirect'),
      '#description' => t('If you want to create an HTTP redirect from your branch terms to the trunk term, please, choose the HTTP redirect code here.'),
      '#required' => TRUE,
      '#options' => $options,
      '#default_value' => TERM_MERGE_NO_REDIRECT,
    );
  }
  else {
    $form['redirect'] = array(
      '#markup' => t('Enable the module ' . l('Redirect', 'http://drupal.org/project/redirect') . ' if you want to do an HTTP redirect from your term branch to the term trunk.'),
    );
  }

  if (module_exists('synonyms')) {
    $options = array();
    foreach (synonyms_synonyms_fields($vocabulary) as $field_name) {
      $options[$field_name] = $instances[$field_name]['label'];
    }
    $form['synonyms'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Add as Synonyms'),
      '#description' => t('Synonyms module allows you to add branch terms as synonyms into any of fields, enabled as sources of synonyms in vocabulary. Check the fields into which you would like to add branch terms as synonyms. <b>Important note:</b> the values will be added until the cardinality limit for the selected fields is reached.'),
      '#options' => $options,
    );
  }
  else {
    $form['synonyms'] = array(
      '#markup' => t('Enable the module ' . l('Synonyms', 'http://drupal.org/project/synonyms') . ' if you want to be able to add branch terms as synonyms into a field of your trunk term.'),
    );
  }

  $form['step'] = array(
    '#type' => 'textfield',
    '#title' => t('Step'),
    '#description' => t('Please, specify how many terms to process per script run in batch. If you are hitting time or memory limits in your PHP, decrease this number.'),
    '#default_value' => 40,
    '#required' => TRUE,
    '#element_validate' => array('element_validate_integer_positive'),
  );

  return $form;
}

/**
 * Return merge settings array.
 *
 * Output of this function should be used for supplying into term_merge()
 * function or for triggering actions_do('term_merge_action', ...) action. This
 * function should be invoked in a form submit hanlder for a form that used
 * term_merge_merge_options_elements() for generating merge settings elements.
 * It will process data and return an array of merge settings, according to the
 * data user has submitted in your form.
 *
 * @param array $merge_settings_element
 *   That part of form that was generated by term_merge_merge_options_elements()
 * @param array $form_state
 *   Form state array of the submitted form
 * @param array $form
 *   Form array of the submitted form
 *
 * @return array
 *   Array of merge settings that can be used for calling term_merge() or
 *   invoking 'term_merge_action' action
 *
 * @see term_merge_merge_options_elements()
 */
function term_merge_merge_options_submit($merge_settings_element, &$form_state, $form) {
  $merge_settings = array(
    'term_branch_keep' => (bool) $merge_settings_element['term_branch_keep']['#value'],
    'merge_fields' => array_values(array_filter($merge_settings_element['merge_fields']['#value'])),
    'keep_only_unique' => (bool) $merge_settings_element['keep_only_unique']['#value'],
    'redirect' => isset($merge_settings_element['redirect']['#value']) ? $merge_settings_element['redirect']['#value'] : TERM_MERGE_NO_REDIRECT,
    'synonyms' => isset($merge_settings_element['synonyms']['#value']) ? array_values(array_filter($merge_settings_element['synonyms']['#value'])) : array(),
    'step' => (int) $merge_settings_element['step']['#value'],
  );
  return $merge_settings;
}
